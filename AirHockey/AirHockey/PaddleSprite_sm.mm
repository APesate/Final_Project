/*
 * ex: set ro:
 * DO NOT EDIT.
 * generated by smc (http://smc.sourceforge.net/)
 * from file : PaddleSprite.sm
 */


//
//PaddleSprite FSM
//


#import "EnemyPaddleDefs.h"
#import "PaddleSprite.h"
#import "PaddleSprite_sm.h"
// Class declarations.
@implementation PaddleSpriteMap
    static PaddleSpriteMap_Defending *gPaddleSpriteMap_Defending = nil;
    static PaddleSpriteMap_Attacking *gPaddleSpriteMap_Attacking = nil;
    static PaddleSpriteMap_FallingBack *gPaddleSpriteMap_FallingBack = nil;

+ (PaddleSpriteMap_Defending*)Defending;
{
    if (!gPaddleSpriteMap_Defending)
    {
        gPaddleSpriteMap_Defending = [[PaddleSpriteMap_Defending alloc] initWithName:@"PaddleSpriteMap::Defending" stateId:0];
    }
    return gPaddleSpriteMap_Defending;
}

+ (PaddleSpriteMap_Attacking*)Attacking;
{
    if (!gPaddleSpriteMap_Attacking)
    {
        gPaddleSpriteMap_Attacking = [[PaddleSpriteMap_Attacking alloc] initWithName:@"PaddleSpriteMap::Attacking" stateId:0];
    }
    return gPaddleSpriteMap_Attacking;
}

+ (PaddleSpriteMap_FallingBack*)FallingBack;
{
    if (!gPaddleSpriteMap_FallingBack)
    {
        gPaddleSpriteMap_FallingBack = [[PaddleSpriteMap_FallingBack alloc] initWithName:@"PaddleSpriteMap::FallingBack" stateId:0];
    }
    return gPaddleSpriteMap_FallingBack;
}

+ (void) cleanupStates
{
    [gPaddleSpriteMap_Defending S_RELEASE]; gPaddleSpriteMap_Defending = nil;
    [gPaddleSpriteMap_Attacking S_RELEASE]; gPaddleSpriteMap_Attacking = nil;
    [gPaddleSpriteMap_FallingBack S_RELEASE]; gPaddleSpriteMap_FallingBack = nil;
}
@end

@implementation PaddleSpriteState
- (void)Entry:(PaddleSpriteContext*)context
{
}
- (void)Exit:(PaddleSpriteContext*)context
{
}
- (void)attack:(PaddleSpriteContext*)context;
{
    [self Default:context];
}
- (void)defend:(PaddleSpriteContext*)context;
{
    [self Default:context];
}
- (void)fallBack:(PaddleSpriteContext*)context;
{
    [self Default:context];
}
- (void)fallback:(PaddleSpriteContext*)context;
{
    [self Default:context];
}
- (void)update:(PaddleSpriteContext*)context :(ccTime)delta;
{
    [self Default:context];
}

- (void)Default:(PaddleSpriteContext*)context;
{
    NSAssert( NO, @"Default transition" );
}
@end


@implementation PaddleSpriteMap_Default

- (void)attack:(PaddleSpriteContext*)context;
{
}

- (void)defend:(PaddleSpriteContext*)context;
{
}

- (void)update:(PaddleSpriteContext*)context :(ccTime)delta;
{
}

- (void)fallback:(PaddleSpriteContext*)context;
{
}
@end
@implementation PaddleSpriteMap_Defending
- (void)Entry:(PaddleSpriteContext*)context;

{
    PaddleSprite *ctxt = [context owner];

    [ctxt runAnimation:pDefendingAnimation];
}
- (void)Exit:(PaddleSpriteContext*)context;

{
    PaddleSprite *ctxt = [context owner];

    [ctxt startFallingBackTimer];
    [ctxt stopDefendingTimer];
}

- (void)attack:(PaddleSpriteContext*)context;
{
    [[context state] Exit:context];
    [context setState:[PaddleSpriteMap Attacking]];
    [[context state] Entry:context];
}

- (void)defend:(PaddleSpriteContext*)context;
{
    [[context state] Exit:context];
    [context setState:[PaddleSpriteMap Defending]];
    [[context state] Entry:context];
}

- (void)update:(PaddleSpriteContext*)context :(ccTime)delta;
{
    PaddleSprite *ctxt = [context owner];
    PaddleSpriteState* EndStateName = [context state];

    [context clearState];
    [ctxt updateDefending:delta];
    [context setState:EndStateName];
}
@end

@implementation PaddleSpriteMap_Attacking
- (void)Entry:(PaddleSpriteContext*)context;

{
    PaddleSprite *ctxt = [context owner];

    [ctxt runAnimation:pAttackingAnimation];
    [ctxt startAttackingTimer];
}
- (void)Exit:(PaddleSpriteContext*)context;

{
    PaddleSprite *ctxt = [context owner];

    [ctxt stopAttackingTimer];
}

- (void)attack:(PaddleSpriteContext*)context;
{
    [[context state] Exit:context];
    [context setState:[PaddleSpriteMap Attacking]];
    [[context state] Entry:context];
}

- (void)fallBack:(PaddleSpriteContext*)context;
{
    [[context state] Exit:context];
    [context setState:[PaddleSpriteMap FallingBack]];
    [[context state] Entry:context];
}

- (void)update:(PaddleSpriteContext*)context :(ccTime)delta;
{
    PaddleSprite *ctxt = [context owner];
    PaddleSpriteState* EndStateName = [context state];

    [context clearState];
    [ctxt updateAttacking:delta];
    [context setState:EndStateName];
}
@end

@implementation PaddleSpriteMap_FallingBack
- (void)Entry:(PaddleSpriteContext*)context;

{
    PaddleSprite *ctxt = [context owner];

    [ctxt runAnimation:pFallBackAnimation];
    [ctxt stopFallingBackTimer];
}
- (void)Exit:(PaddleSpriteContext*)context;

{
    PaddleSprite *ctxt = [context owner];

    [ctxt startDefendingTimer];
}

- (void)defend:(PaddleSpriteContext*)context;
{
    [[context state] Exit:context];
    [context setState:[PaddleSpriteMap Defending]];
    [[context state] Entry:context];
}
@end

@implementation PaddleSpriteContext
- (id)initWithOwner:(PaddleSprite*)owner;
{
    self = [super initWithState:[PaddleSpriteMap Defending]];
    if (!self)
{
        return nil;
    }
    _owner = owner;
    return self;
}
- (id)initWithOwner:(PaddleSprite*)owner state:(SMCState*)aState;
{
    self = [super initWithState: aState];
    if (!self)
{
        return nil;
    }
    _owner = owner;
    return self;
}
- (void)dealloc
{
    [PaddleSpriteMap cleanupStates];
    [super S_DEALLOC];
}
- (PaddleSpriteState*)state;
{
    return (PaddleSpriteState*)_state;
}
- (PaddleSprite*)owner;
{
    return _owner;
}
- (void)enterStartState;
{
    [[self state] Entry:self];
}

- (void)attack;
{
    [[self state] attack:self];
}

- (void)defend;
{
    [[self state] defend:self];
}

- (void)fallBack;
{
    [[self state] fallBack:self];
}

- (void)fallback;
{
    [[self state] fallback:self];
}

- (void)update:(ccTime)delta;
{
    [[self state] update:self :delta];
}
@end

/*
 * Local variables:
 *  buffer-read-only: t
 * End:
 */
